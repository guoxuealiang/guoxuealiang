<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Es原理与使用 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、ElasticSearch基本使用1.1、基本介绍1.1.1、ElasticSearch的特色ElasticSearch是实时的分布式搜索分析引擎，内部使用Lucene做索引与搜索  准实时性：新增到ES中的数据在1秒后就可以被检索到，这种新增数据对搜索的可见性称为”准实时搜索” 分布式：意味着可以动态调整集群规模，弹性扩容 集群规模：可以扩展到上百台服务器，处理PB级结构化或非结构化数据 各">
<meta property="og:type" content="article">
<meta property="og:title" content="Es原理与使用">
<meta property="og:url" content="http://example.com/post/Es%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、ElasticSearch基本使用1.1、基本介绍1.1.1、ElasticSearch的特色ElasticSearch是实时的分布式搜索分析引擎，内部使用Lucene做索引与搜索  准实时性：新增到ES中的数据在1秒后就可以被检索到，这种新增数据对搜索的可见性称为”准实时搜索” 分布式：意味着可以动态调整集群规模，弹性扩容 集群规模：可以扩展到上百台服务器，处理PB级结构化或非结构化数据 各">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-1.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-2.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-3.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-4.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-5.jpg">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-6.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-7.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-8.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-9.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-10.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-11.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-12.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-13.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-14.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-15.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-16.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-17.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-18.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-19.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-20.png">
<meta property="og:image" content="e:/blog/blog/source_posts/image/es-21.png">
<meta property="article:published_time" content="2022-11-18T01:42:22.000Z">
<meta property="article:modified_time" content="2022-11-21T13:45:43.229Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/blog/blog/source_posts/image/es-1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Es原理与使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/Es%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8.html" class="article-date">
  <time datetime="2022-11-18T01:42:22.000Z" itemprop="datePublished">2022-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Es原理与使用
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、ElasticSearch基本使用"><a href="#1、ElasticSearch基本使用" class="headerlink" title="1、ElasticSearch基本使用"></a>1、ElasticSearch基本使用</h2><h3 id="1-1、基本介绍"><a href="#1-1、基本介绍" class="headerlink" title="1.1、基本介绍"></a>1.1、基本介绍</h3><h4 id="1-1-1、ElasticSearch的特色"><a href="#1-1-1、ElasticSearch的特色" class="headerlink" title="1.1.1、ElasticSearch的特色"></a>1.1.1、ElasticSearch的特色</h4><p>ElasticSearch是实时的分布式搜索分析引擎，内部使用Lucene做索引与搜索</p>
<ul>
<li>准实时性：新增到ES中的数据在1秒后就可以被检索到，这种新增数据对搜索的可见性称为”准实时搜索”</li>
<li>分布式：意味着可以动态调整集群规模，弹性扩容</li>
<li>集群规模：可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>
<li>各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其工作</li>
</ul>
<p>Lucene是Java语言编写的全文搜索框架，用于处理纯文本的数据，但它只是一个库，提供建立索引、执行搜索等接口，但不包含分布式服务，这些正是 ES 做的</p>
<h4 id="1-1-2-ElasticSearch使用场景"><a href="#1-1-2-ElasticSearch使用场景" class="headerlink" title="1.1.2 ElasticSearch使用场景"></a>1.1.2 ElasticSearch使用场景</h4><p>ElasticSearch广泛应用于各行业领域， 比如维基百科， GitHub的代码搜索，电商网站的大数据日志统计分析， BI系统报表统计分析等。</p>
<ul>
<li><p>提供分布式的搜索引擎和数据分析引擎</p>
<p>比如百度，网站的站内搜索，IT系统的检索， 数据分析比如热点词统计， 电商网站商品TOP排名等。</p>
</li>
<li><p>全文检索，结构化检索，数据分析</p>
<p>支持全文检索， 比如查找包含指定名称的商品信息； 支持结构检索， 比如查找某个分类下的所有商品信息； </p>
<p>还可以支持高级数据分析， 比如统计某个商品的点击次数， 某个商品有多少用户购买等等。</p>
</li>
<li><p>支持海量数据准实时的处理</p>
<p>采用分布式节点， 将数据分散到多台服务器上去存储和检索， 实现海量数据的处理， 比如统计用户的行为日志， 能够在秒级别对数据进行检索和分析。</p>
</li>
</ul>
<h4 id="1-1-3-ElasticSearch基本概念介绍"><a href="#1-1-3-ElasticSearch基本概念介绍" class="headerlink" title="1.1.3 ElasticSearch基本概念介绍"></a>1.1.3 ElasticSearch基本概念介绍</h4><table>
<thead>
<tr>
<th>ElasticSearch</th>
<th>Relational Database</th>
</tr>
</thead>
<tbody><tr>
<td>Index</td>
<td>Database</td>
</tr>
<tr>
<td>Type</td>
<td>Table</td>
</tr>
<tr>
<td>Document</td>
<td>Row</td>
</tr>
<tr>
<td>Field</td>
<td>Column</td>
</tr>
<tr>
<td>Mapping</td>
<td>Schema</td>
</tr>
<tr>
<td>Everything is indexed</td>
<td>Index</td>
</tr>
<tr>
<td>Query DSL</td>
<td>SQL</td>
</tr>
<tr>
<td>GET http://…</td>
<td>SELECT * FROM table…</td>
</tr>
<tr>
<td>PUT http://…</td>
<td>UPDATE table SET…</td>
</tr>
</tbody></table>
<p><img src="E:\blog\blog\source_posts\image\es-1.png" alt="es-1"></p>
<ul>
<li><p>索引（Index)</p>
<p>相比传统的关系型数据库，索引相当于SQL中的一个【数据库】，或者一个数据存储方案(schema)。</p>
</li>
<li><p>类型（Type）</p>
<p>一个索引内部可以定义一个或多个类型， 在传统关系数据库来说， 类型相当于【表】的概念。</p>
</li>
<li><p>文档（Document）</p>
<p>文档是Lucene索引和搜索的原子单位，它是包含了一个或多个域的容器，采用JSON格式表示。相当于传统数据库【行】概念</p>
</li>
<li><p>集群（Cluster）</p>
<p>集群是由一台及以上主机节点组成并提供存储及搜索服务， 多节点组成的集群拥有冗余能力，它可以在一个或几个节点出现故障时保证服务的整体可用性。</p>
</li>
<li><p>节点（Node）</p>
<p>Node为集群中的单台节点，其可以为master节点亦可为slave节点（节点属性由集群内部选举得出）并提供存储相关数据的功能</p>
</li>
<li><p>切片（shards)  分片</p>
<p>切片是把一个大文件分割成多个小文件然后分散存储在集群中的多个节点上， 可以将其看作mysql的分库分表概念。 Shard有两种类型：primary主片和replica副本，primary用于文档存储，Replica shard是Primary Shard的副本，用于冗余数据及提高搜索性能。</p>
<p><img src="E:\blog\blog\source_posts\image\es-2.png" alt="es-2"></p>
</li>
</ul>
<p>注意： ES7之后Type被舍弃，只有Index(等同于数据库+表定义）和Document（文档，行记录）。</p>
<h3 id="1-2-ElasticSearch安装"><a href="#1-2-ElasticSearch安装" class="headerlink" title="1.2 ElasticSearch安装"></a>1.2 ElasticSearch安装</h3><h4 id="1-2-1-下载ElasticSearch服务"><a href="#1-2-1-下载ElasticSearch服务" class="headerlink" title="1.2.1 下载ElasticSearch服务"></a>1.2.1 下载ElasticSearch服务</h4><p>下载最新版ElasticSearch7.10.2： <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/start">https://www.elastic.co/cn/start</a></p>
<h4 id="1-2-2-解压安装包"><a href="#1-2-2-解压安装包" class="headerlink" title="1.2.2 解压安装包"></a>1.2.2 解压安装包</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -xvf elasticsearch-7.10.2-linux-x86_64.tar.gz</code></pre>

<h4 id="1-2-3-创建elsearch用户"><a href="#1-2-3-创建elsearch用户" class="headerlink" title="1.2.3 创建elsearch用户"></a>1.2.3 创建elsearch用户</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## ElasticSearch不能以Root身份运行， 需要单独创建一个用户， 并赋予目录权限
groupadd elsearch

useradd elsearch -g elsearch -p elasticsearch

chown -R elsearch:elsearch  &#x2F;opt&#x2F;elasticsearch&#x2F;elasticsearch-7.10.2</code></pre>

<h4 id="1-2-4-修改配置文件"><a href="#1-2-4-修改配置文件" class="headerlink" title="1.2.4 修改配置文件"></a>1.2.4 修改配置文件</h4><p>vi config/elasticsearch.yml,  默认情况下会绑定本机地址， 外网不能访问， 这里要修改下：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># node名称
node.name: node-1
# 外网访问地址
network.host: 0.0.0.0
discovery.seed_hosts: [&quot;node-1&quot;]
cluster.initial_master_nodes: [&quot;node-1&quot;]</code></pre>

<h4 id="1-2-5-关闭防火墙"><a href="#1-2-5-关闭防火墙" class="headerlink" title="1.2.5 关闭防火墙"></a>1.2.5 关闭防火墙</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop  firewalld.service
systemctl disable  firewalld.service</code></pre>

<h4 id="1-2-6-JDK环境变量的配置"><a href="#1-2-6-JDK环境变量的配置" class="headerlink" title="1.2.6 JDK环境变量的配置"></a>1.2.6 JDK环境变量的配置</h4><p>1）最新版的ElasticSearch需要JDK11版本， 下载<a target="_blank" rel="noopener" href="https://download.oracle.com/otn/java/jdk/11.0.4+10/cf1bbcbf431a474eb9fc550051f4ee78/jdk-11.0.4_linux-x64_bin.tar.gz">JDK11压缩包</a>， 并进行解压。</p>
<p>2）修改环境配置文件</p>
<p>vi bin/elasticsearch-env ，参照以下位置， 追加一行， 设置JAVA_HOME， 指定JDK11路径。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdk-11.0.11

# now set the path to java
if [ ! -z &quot;$JAVA_HOME&quot; ]; then
  JAVA&#x3D;&quot;$JAVA_HOME&#x2F;bin&#x2F;java&quot;
else
  if [ &quot;$(uname -s)&quot; &#x3D; &quot;Darwin&quot; ]; then
    # OSX has a different structure
    JAVA&#x3D;&quot;$ES_HOME&#x2F;jdk&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java&quot;
  else
    JAVA&#x3D;&quot;$ES_HOME&#x2F;jdk&#x2F;bin&#x2F;java&quot;
  fi
fi</code></pre>

<h4 id="1-2-7-启动ElasticSearch"><a href="#1-2-7-启动ElasticSearch" class="headerlink" title="1.2.7 启动ElasticSearch"></a>1.2.7 启动ElasticSearch</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 切换用户
su elsearch
## 以后台常驻方式启动
bin&#x2F;elasticsearch -d </code></pre>

<p>PS: 出现max virtual memory areas vm.max_map_count [65530] is too low, increase to at least 错误信息，如图：</p>
<p><img src="E:\blog\blog\source_posts\image\es-3.png" alt="es-3"></p>
<p>修改系统配置：</p>
<p>vi /etc/sysctl.conf , 添加 vm.max_map_count=655360，保存退出后，执行 sysctl -p，使之生效。</p>
<pre class="line-numbers language-none"><code class="language-none">vm.max_map_count&#x3D;655360</code></pre>

<p>vi /etc/security/limits.conf，在文件末尾添加如下配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* soft nofile 65536

* hard nofile 131072

* soft nproc 2048

* hard nproc 4096

elsearch soft nproc 125535

elsearch hard nproc 125535</code></pre>

<h4 id="1-2-8-访问验证"><a href="#1-2-8-访问验证" class="headerlink" title="1.2.8 访问验证"></a>1.2.8 访问验证</h4><p>访问地址：<a target="_blank" rel="noopener" href="http://ip:9200/_cat/health">http://ip:9200/_cat/health</a></p>
<p>启动状态有green、yellow和red。 green是代表启动正常。</p>
<p><img src="E:\blog\blog\source_posts\image\es-4.png" alt="es-4"></p>
<h3 id="1-3-Kibana服务安装"><a href="#1-3-Kibana服务安装" class="headerlink" title="1.3 Kibana服务安装"></a>1.3 Kibana服务安装</h3><p>Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。</p>
<h4 id="1-3-1-下载安装包"><a href="#1-3-1-下载安装包" class="headerlink" title="1.3.1 下载安装包"></a>1.3.1 下载安装包</h4><p>到官网下载， <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/kibana/kibana-7.10.2-windows-x86_64.zip">Kibana安装包</a>,  与之对应7.10.2版本， 选择Linux 64位版本下载，并进行解压。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 解压
tar -xvf kibana-7.10.2-linux-x86_64.tar.gz
# 重命名为 kibana-7.10.2
mv kibana-7.10.2-linux-x86_64&#x2F; kibana-7.10.2</code></pre>

<h4 id="1-3-2-创建的elsearch用户"><a href="#1-3-2-创建的elsearch用户" class="headerlink" title="1.3.2 创建的elsearch用户"></a>1.3.2 创建的elsearch用户</h4><p>Kibana启动不能使用root用户， 使用上面创建的elsearch用户， 进行赋权：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chown -R elsearch:elsearch kibana-7.10.2</code></pre>

<h4 id="1-3-3-修改配置文件"><a href="#1-3-3-修改配置文件" class="headerlink" title="1.3.3 修改配置文件"></a>1.3.3 修改配置文件</h4><p>vi config/kibana.yml , 修改以下配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 服务端口
server.port: 5601
# 服务地址
server.host: &quot;0.0.0.0&quot;
# elasticsearch服务地址
elasticsearch.hosts: [&quot;http:&#x2F;&#x2F;192.168.10.30:9200&quot;]</code></pre>

<h4 id="1-3-4-启动kibana"><a href="#1-3-4-启动kibana" class="headerlink" title="1.3.4 启动kibana"></a>1.3.4 启动kibana</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;kibana -q</code></pre>

<p>看到以下日志， 代表启动正常</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">log   [01:40:00.143] [info][listening] Server running at http:&#x2F;&#x2F;0.0.0.0:5601</code></pre>

<p>如果出现启动失败的情况， 要检查集群各节点的日志， 确保服务正常运行状态。</p>
<h4 id="1-3-5-访问服务"><a href="#1-3-5-访问服务" class="headerlink" title="1.3.5 访问服务"></a>1.3.5 访问服务</h4><p><a target="_blank" rel="noopener" href="http://ip:5601/app/home#/">http://ip:5601/app/home#/</a></p>
<h3 id="1-4-ES的基础操作"><a href="#1-4-ES的基础操作" class="headerlink" title="1.4 ES的基础操作"></a>1.4 ES的基础操作</h3><h4 id="1-4-1-登录Kibana管理后台"><a href="#1-4-1-登录Kibana管理后台" class="headerlink" title="1.4.1 登录Kibana管理后台"></a>1.4.1 登录Kibana管理后台</h4><p>地址：  <a target="_blank" rel="noopener" href="http://ip:5601/">http://ip:5601</a></p>
<p>进入”Dev Tools”栏，在Console中输入命令进行操作：</p>
<h4 id="1-4-2-索引"><a href="#1-4-2-索引" class="headerlink" title="1.4.2 索引"></a>1.4.2 索引</h4><p>新建索引 orders</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 创建索引
PUT orders</code></pre>

<p>2）查询索引 orders</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 查询索引
GET orders</code></pre>

<p>3）删除索引 orders</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 删除索引
DELETE orders</code></pre>

<p>4）索引的设置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 设置索引
PUT orders
&#123;
  &quot;settings&quot;: &#123;
    &quot;index&quot;: &#123;
      &quot;number_of_shards&quot;: 1, 
      &quot;number_of_replicas&quot;: 0
    &#125;
  &#125;
&#125;</code></pre>

<h4 id="1-4-3-文档"><a href="#1-4-3-文档" class="headerlink" title="1.4.3 文档"></a>1.4.3 文档</h4><p>1）创建文档</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 创建文档，生成默认的文档id
POST orders&#x2F;_doc
&#123;
  &quot;name&quot;: &quot;袜子1双&quot;,
  &quot;price&quot;: &quot;200&quot;,
  &quot;count&quot;: 1,
  &quot;address&quot;: &quot;北京市&quot;
&#125;
## 创建文档，生成自定义文档id
POST orders&#x2F;_doc&#x2F;1
&#123;
  &quot;name&quot;: &quot;袜子1双&quot;,
  &quot;price&quot;: &quot;2&quot;,
  &quot;count&quot;: 1,
  &quot;address&quot;: &quot;北京市&quot;
&#125;</code></pre>

<p>2）查询文档</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 根据指定的id查询
GET orders&#x2F;_doc&#x2F;1
## 根据指定条件查询文档
GET orders&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;address&quot;: &quot;北京市&quot;
    &#125;
  &#125;
&#125;
## 查询全部文档
GET orders&#x2F;_search</code></pre>

<p>3） 更新文档</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 更新文档 覆盖
POST orders&#x2F;_doc&#x2F;1
&#123;
  &quot;price&quot;: &quot;200&quot;
&#125;
## 更新文档 跟新指定字段值
POST orders&#x2F;_update&#x2F;1
&#123;
  &quot;doc&quot;: &#123;
    &quot;price&quot;: &quot;200&quot;
  &#125;
&#125;</code></pre>

<p>4）删除文档</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 删除文档
DELETE orders&#x2F;_doc&#x2F;1</code></pre>

<h4 id="1-4-4-映射"><a href="#1-4-4-映射" class="headerlink" title="1.4.4 映射"></a>1.4.4 映射</h4><p>对于映射，只能进行字段添加，不能对字段进行修改或删除，如有需要，则重新创建映射。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 设置mapping信息
PUT orders&#x2F;_mappings
&#123;
  &quot;properties&quot;:&#123;
    &quot;price&quot;: &#123;
      &quot;type&quot;: &quot;long&quot;
    &#125;
  &#125;
&#125;
## 设置分片和映射
PUT orders
&#123;
  &quot;settings&quot;: &#123;
    &quot;index&quot;: &#123;
      &quot;number_of_shards&quot;: 1, 
      &quot;number_of_replicas&quot;: 0
    &#125;
  &#125;,
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;name&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;,
      &quot;price&quot;: &#123;
        &quot;type&quot;: &quot;long&quot;
      &#125;,
      &quot;count&quot;: &#123;
        &quot;type&quot;: &quot;long&quot;
      &#125;,
      &quot;address&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;
    &#125;
  &#125;
&#125;</code></pre>



<h3 id="1-5-ES数据类型"><a href="#1-5-ES数据类型" class="headerlink" title="1.5 ES数据类型"></a>1.5 ES数据类型</h3><h4 id="1-5-1-整体数据类型结构"><a href="#1-5-1-整体数据类型结构" class="headerlink" title="1.5.1 整体数据类型结构"></a>1.5.1 整体数据类型结构</h4><p><img src="E:\blog\blog\source_posts\image\es-5.jpg" alt="es-5"></p>
<h4 id="1-5-3-Date时间类型"><a href="#1-5-3-Date时间类型" class="headerlink" title="1.5.3 Date时间类型"></a>1.5.3 Date时间类型</h4><p>数据库里的日期类型需要规范具体的传入格式， ES是可以控制，自适应处理。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## ES的Date类型允许可以使用的格式：yyyy-MM-dd
PUT my_date_index&#x2F;_doc&#x2F;1
&#123;
    &quot;date&quot;: &quot;2021-01-01&quot;
&#125; 
## ES的Date类型允许可以使用的格式：yyyy-MM-dd HH:mm:ss
PUT my_date_index&#x2F;_doc&#x2F;2
&#123;
    &quot;date&quot;: &quot;2021-01-01T12:10:30Z&quot;
&#125; 
## ES的Date类型允许可以使用的格式：epoch_millis(毫秒值)
PUT my_date_index&#x2F;_doc&#x2F;3
&#123;
    &quot;date&quot;: 1520071600001
&#125; 


## 查看日期数据：
GET my_date_index&#x2F;_mapping</code></pre>

<h4 id="1-5-4-复合类型"><a href="#1-5-4-复合类型" class="headerlink" title="1.5.4 复合类型"></a>1.5.4 复合类型</h4><p>1）数组</p>
<p>在Elasticsearch中，数组不需要声明专用的字段数据类型。但是，在数组中的所有值都必须具有相同的数据类型。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 错误示例
POST orders&#x2F;_doc&#x2F;1
&#123;
  &quot;goodsName&quot;:[&quot;足球&quot;,&quot;篮球&quot;,&quot;兵乓球&quot;, 3]
&#125;
## 正确示例
POST orders&#x2F;_doc&#x2F;1
&#123;
  &quot;goodsName&quot;:[&quot;足球&quot;,&quot;篮球&quot;,&quot;兵乓球&quot;]
&#125;</code></pre>

<p>2）对象</p>
<p>用于存储单个JSON对象， 类似于JAVA中的对象类型， 可以有多个值， 比如LIST，可以包含多个对象。但是，LIST&lt; Object &gt;只能作为整体， 不能独立的索引查询。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 新增第一组数据， 组别为美国，两个人。
POST my_index&#x2F;_doc&#x2F;1
&#123;
  &quot;group&quot; : &quot;america&quot;,  
  &quot;users&quot; : [   
    &#123;   
      &quot;name&quot; : &quot;John&quot;,  
      &quot;age&quot; :  &quot;22&quot; 
    &#125;,  
    &#123;   
      &quot;name&quot; : &quot;Alice&quot;, 
      &quot;age&quot; :  &quot;21&quot; 
    &#125;   
  ]
&#125;   
# 新增第二组数据， 组别为英国， 两个人。
POST my_index&#x2F;_doc&#x2F;2
&#123;   
  &quot;group&quot; : &quot;england&quot;,  
  &quot;users&quot; : [   
    &#123;   
      &quot;name&quot; : &quot;lucy&quot;,  
      &quot;age&quot; :  &quot;21&quot; 
    &#125;,  
    &#123;   
      &quot;name&quot; : &quot;John&quot;,  
      &quot;age&quot; :  &quot;32&quot; 
    &#125;   
  ] 
&#125;
## 搜索name为John，age为21的数据
GET my_index&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: [
                &#123;
                    &quot;match&quot;: &#123;
                        &quot;users.name&quot;: &quot;John&quot;
                    &#125;
                &#125;,
                &#123;
                    &quot;match&quot;: &#123;
                        &quot;users.age&quot;: &quot;21&quot;
                    &#125;
                &#125;
            ]
        &#125;
    &#125;
&#125;</code></pre>

<p>结果可以看到， 这两组数据都能找出，因为每一组数据都是作为一个整体进行搜索匹配， 而非具体某一条数据。</p>
<p>3）嵌套</p>
<p>用于存储多个JSON对象组成的数组，<code>nested</code> 类型是 <code>object</code> 类型中的一个特例，可以让对象数组独立索引和查询。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 1. 创建nested类型的索引
PUT my_index
&#123;   
  &quot;mappings&quot;: &#123; 
    &quot;properties&quot;: &#123; 
      &quot;users&quot;: &#123;    
        &quot;type&quot;: &quot;nested&quot;    
      &#125; 
    &#125;   
  &#125; 
&#125;
## 2. 新增数据
# 新增第一组数据， 组别为美国，两个人。
POST my_index&#x2F;_doc&#x2F;1
&#123;
  &quot;group&quot; : &quot;america&quot;,  
  &quot;users&quot; : [   
    &#123;   
      &quot;name&quot; : &quot;John&quot;,  
      &quot;age&quot; :  &quot;22&quot; 
    &#125;,  
    &#123;   
      &quot;name&quot; : &quot;Alice&quot;, 
      &quot;age&quot; :  &quot;21&quot; 
    &#125;   
  ]
&#125;   
# 新增第二组数据， 组别为英国， 两个人。
POST my_index&#x2F;_doc&#x2F;2
&#123;   
  &quot;group&quot; : &quot;england&quot;,  
  &quot;users&quot; : [   
    &#123;   
      &quot;name&quot; : &quot;lucy&quot;,  
      &quot;age&quot; :  &quot;21&quot; 
    &#125;,  
    &#123;   
      &quot;name&quot; : &quot;John&quot;,  
      &quot;age&quot; :  &quot;32&quot; 
    &#125;   
  ] 
&#125;
## 3. 再次查询
GET my_index&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: [
                &#123;
                    &quot;nested&quot;: &#123;
                        &quot;path&quot;: &quot;users&quot;,
                        &quot;query&quot;: &#123;
                            &quot;bool&quot;: &#123;
                                &quot;must&quot;: [
                                    &#123;
                                        &quot;match&quot;: &#123;
                                            &quot;users.name&quot;: &quot;John&quot;
                                        &#125;
                                    &#125;,
                                    &#123;
                                        &quot;match&quot;: &#123;
                                            &quot;users.age&quot;: &quot;21&quot;
                                        &#125;
                                    &#125;
                                ]
                            &#125;
                        &#125;
                    &#125;
                &#125;
            ]
        &#125;
    &#125;
&#125;</code></pre>

<p>采用以前的条件， 这个时候查不到任何结果， 将年龄改成22， 就可以找出对应的数据</p>
<h4 id="1-5-5-GEO地理位置类型"><a href="#1-5-5-GEO地理位置类型" class="headerlink" title="1.5.5 GEO地理位置类型"></a>1.5.5 GEO地理位置类型</h4><p>现在大部分APP都有基于位置搜索的功能， 比如交友、购物应用等。这些功能是基于GEO搜索实现的。</p>
<p>对于GEO地理位置类型，分为地理坐标类型：Geo-point， 和形状：Geo-shape 两种类型。</p>
<table>
<thead>
<tr>
<th align="left">经纬度</th>
<th align="left">英文</th>
<th align="left">简写</th>
<th align="left">正数</th>
<th>负数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">纬度</td>
<td align="left">latitude</td>
<td align="left">lat</td>
<td align="left">北纬</td>
<td>南纬</td>
</tr>
<tr>
<td align="left">经度</td>
<td align="left">longitude</td>
<td align="left">lon或lng</td>
<td align="left">东经</td>
<td>西经</td>
</tr>
</tbody></table>
<p>1）创建地理位置索引</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PUT my_locations
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;location&quot;: &#123;
        &quot;type&quot;: &quot;geo_point&quot;
      &#125;
    &#125;
  &#125;
&#125;</code></pre>

<p>2）添加地理位置数据</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 采用object对象类型
PUT my_locations&#x2F;_doc&#x2F;1
&#123;
    &quot;user&quot;: &quot;张三&quot;,
    &quot;text&quot;: &quot;Geo-point as an object&quot;,
    &quot;location&quot;: &#123;
        &quot;lat&quot;: 41.12,
        &quot;lon&quot;: -71.34
    &#125;
&#125;
# 采用string类型
PUT my_locations&#x2F;_doc&#x2F;2
&#123;
    &quot;user&quot;: &quot;李四&quot;,
    &quot;text&quot;: &quot;Geo-point as a string&quot;,
    &quot;location&quot;: &quot;45.12,-75.34&quot;
&#125;
# 采用geohash类型（geohash算法可以将多维数据映射为一串字符）
PUT my_locations&#x2F;_doc&#x2F;3
&#123;
    &quot;user&quot;: &quot;王二麻子&quot;,
    &quot;text&quot;: &quot;Geo-point as a geohash&quot;,
    &quot;location&quot;: &quot;drm3btev3e86&quot;
&#125;
# 采用array数组类型
PUT my_locations&#x2F;_doc&#x2F;4
&#123;
    &quot;user&quot;: &quot;木头老七&quot;,
    &quot;text&quot;: &quot;Geo-point as an array&quot;,
    &quot;location&quot;: [
        -80.34,
        51.12
    ]
&#125;</code></pre>

<p>3）需求</p>
<p>搜索出距离我{“lat” : 40,”lon” : -70} 200km范围内的人</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">GET my_locations&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: &#123;
                &quot;match_all&quot;: &#123;&#125;
            &#125;,
            &quot;filter&quot;: &#123;
                &quot;geo_distance&quot;: &#123;
                    &quot;distance&quot;: &quot;200km&quot;,
                    &quot;location&quot;: &#123;
                        &quot;lat&quot;: 40,
                        &quot;lon&quot;: -70
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="2-ES高可用集群配置"><a href="#2-ES高可用集群配置" class="headerlink" title="2. ES高可用集群配置"></a>2. ES高可用集群配置</h2><h3 id="2-1-集群介绍"><a href="#2-1-集群介绍" class="headerlink" title="2.1 集群介绍"></a>2.1 集群介绍</h3><h4 id="2-1-1-主节点（候选主节点）"><a href="#2-1-1-主节点（候选主节点）" class="headerlink" title="2.1.1 主节点（候选主节点）"></a>2.1.1 主节点（候选主节点）</h4><p><img src="E:\blog\blog\source_posts\image\es-6.png" alt="es-6"></p>
<p>主节点负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作， 主节点负荷相对较轻， 客户端请求可以直接发往任何节点， 由对应节点负责分发和返回处理结果。</p>
<p>​    一个节点启动之后， 采用 Zen Discovery机制去寻找集群中的其他节点， 并与之建立连接， 集群会从候选主节点中选举出一个主节点， 并且一个集群只能选举一个主节点， 在某些情况下， 由于网络通信丢包等问题， 一个集群可能会出现多个主节点， 称为“脑裂现象”， 脑裂会存在丢失数据的可能， 因为主节点拥有最高权限， 它决定了什么时候可以创建索引， 分片如何移动等， 如果存在多个主节点， 就会产生冲突， 容易产生数据丢失。要尽量避免这个问题， 可以通过 discovery.zen.minimum_master_nodes 来设置最少可工作的候选主节点个数。  建议设置为（候选主节点/2） + 1 比如三个候选主节点，该配置项为 （3/2）+1 ,来保证集群中有半数以上的候选主节点， 没有足够的master候选节点， 就不会进行master节点选举，减少脑裂的可能。</p>
<p>主节点的参数设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node.master &#x3D; true
node.data &#x3D; false</code></pre>

<h4 id="2-1-2-数据节点"><a href="#2-1-2-数据节点" class="headerlink" title="2.1.2 数据节点"></a>2.1.2 数据节点</h4><p><img src="E:\blog\blog\source_posts\image\es-7.png" alt="es-7"></p>
<p>数据节点负责数据的存储和CRUD等具体操作，数据节点对机器配置要求比较高，首先需要有足够的磁盘空间来存储数据，其次数据操作对系统CPU、Memory和IO的性能消耗都很大。通常随着集群的扩大，需要增加更多的数据节点来提高可用性。</p>
<p>数据节点的参数设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node.master &#x3D; false
node.data &#x3D; true</code></pre>

<h4 id="2-1-3-客户端节点"><a href="#2-1-3-客户端节点" class="headerlink" title="2.1.3 客户端节点"></a>2.1.3 客户端节点</h4><p><img src="E:\blog\blog\source_posts\image\es-8.png" alt="es-8"></p>
<p>客户端节点不做候选主节点， 也不做数据节点的节点，只负责请求的分发、汇总等等，增加客户端节点类型更多是为了负载均衡的处理。</p>
<p>客户端节点的参数设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node.master &#x3D; false
node.data &#x3D; false</code></pre>

<h4 id="2-1-4-提取节点（预处理）"><a href="#2-1-4-提取节点（预处理）" class="headerlink" title="2.1.4 提取节点（预处理）"></a>2.1.4 提取节点（预处理）</h4><p><img src="E:\blog\blog\source_posts\image\es-9.png" alt="es-9"></p>
<p>能执行预处理管道，有自己独立的任务要执行， 在索引数据之前可以先对数据做预处理操作， 不负责数据存储也不负责集群相关的事务。</p>
<p>参数设置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node.ingest &#x3D; true</code></pre>

<h4 id="2-1-5-协调节点"><a href="#2-1-5-协调节点" class="headerlink" title="2.1.5 协调节点"></a>2.1.5 协调节点</h4><p><img src="E:\blog\blog\source_posts\image\es-10.png" alt="es-10"></p>
<p>协调节点，是一种角色，而不是真实的Elasticsearch的节点，不能通过配置项来指定哪个节点为协调节点。集群中的任何节点，都可以充当协调节点的角色。当一个节点A收到用户的查询请求后，会把查询子句分发到其它的节点，然后合并各个节点返回的查询结果，最后返回一个完整的数据集给用户。在这个过程中，节点A扮演的就是协调节点的角色。</p>
<p> ES的一次请求非常类似于Map-Reduce操作。在ES中对应的也是两个阶段，称之为scatter-gather。客户端发出一个请求到集群的任意一个节点，这个节点就是所谓的协调节点，它会把请求转发给含有相关数据的节点(scatter阶段)，这些数据节点会在本地执行请求然后把结果返回给协调节点。协调节点将这些结果汇总(reduce)成一个单一的全局结果集(gather阶段) 。</p>
<h4 id="2-1-6-部落节点"><a href="#2-1-6-部落节点" class="headerlink" title="2.1.6 部落节点"></a>2.1.6 部落节点</h4><p><img src="E:\blog\blog\source_posts\image\es-11.png" alt="es-11"></p>
<p>在多个集群之间充当联合客户端，   它是一个特殊的客户端 ， 可以连接多个集群，在所有连接的集群上执行搜索和其他操作。  部落节点从所有连接的集群中检索集群状态并将其合并成全局集群状态。 掌握这一信息，就可以对所有集群中的节点执行读写操作，就好像它们是本地的。 请注意，部落节点需要能够连接到每个配置的集群中的每个单个节点。 </p>
<h3 id="2-2-集群原理"><a href="#2-2-集群原理" class="headerlink" title="2.2 集群原理"></a>2.2 集群原理</h3><h4 id="2-2-1-集群分布式原理"><a href="#2-2-1-集群分布式原理" class="headerlink" title="2.2.1 集群分布式原理"></a>2.2.1 集群分布式原理</h4><p>集群可以根据节点数， 动态调整主分片与副本数， 做到整个集群有效均衡负载。</p>
<p>单节点状态下：</p>
<p><img src="E:\blog\blog\source_posts\image\es-12.png" alt="es-12"></p>
<p>两个节点状态下， 副本数为1：</p>
<p><img src="E:\blog\blog\source_posts\image\es-13.png" alt="es-13"></p>
<p>三个节点状态下， 副本数为1：</p>
<p><img src="E:\blog\blog\source_posts\image\es-14.png" alt="es-14"></p>
<p>三个节点状态下， 副本数为2：</p>
<p><img src="E:\blog\blog\source_posts\image\es-15.png" alt="es-15"></p>
<h4 id="2-2-2-分片处理机制"><a href="#2-2-2-分片处理机制" class="headerlink" title="2.2.2 分片处理机制"></a>2.2.2 分片处理机制</h4><p>设置分片大小的时候， 需预先做好容量规划， 如果节点数过多， 分片数过少， 那么新的节点将无法分片， 不能做到水平扩展， 并且单个分片数据量太大， 导致数据重新分配耗时过长。</p>
<p> 假设一个集群中有一个主节点、两个数据节点。orders索引的分片分布情况如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PUT orders
&#123;
    &quot;settings&quot;:&#123;
        &quot;number_of_shards&quot;: 2,  ## 主分片一共 2
        &quot;number_of_replicas&quot;: 2  ## 副分片一共 4
    &#125;
&#125;</code></pre>

<p>整个集群中存在P0和P1两个主分片， P0对应的两个R0副本分片， P1对应的是两个R1副本分片。</p>
<p><img src="E:\blog\blog\source_posts\image\es-16.png" alt="es-16"></p>
<h4 id="2-2-3-写索引处理流程"><a href="#2-2-3-写索引处理流程" class="headerlink" title="2.2.3 写索引处理流程"></a>2.2.3 写索引处理流程</h4><p>1）客户端向NODE1发送写请求。</p>
<p>2）NODE1使用文档ID来确定文档属于分片0，通过集群状态中的内容路由表信息获知分片0的主分片位于NODE3，因此请求被转发到NODE3上。</p>
<p>3）NODE3上的主分片执行写操作。如果写入成功，则它将请求并行转发到 NODE1和NODE2的副分片上，等待返回结果。当所有的副分片都报告成功，NODE3将向协调节点报告成功，协调节点再向客户端报告成功。</p>
<p><img src="E:\blog\blog\source_posts\image\es-17.png" alt="es-17"></p>
<h4 id="2-2-4-读取索引处理流程"><a href="#2-2-4-读取索引处理流程" class="headerlink" title="2.2.4 读取索引处理流程"></a>2.2.4 读取索引处理流程</h4><p>1）客户端向NODE1发送读请求。</p>
<p>2）NODE1使用文档ID来确定文档属于分片0，通过集群状态中的内容路由表信息获知分片0有三个副本数据，位于所有的三个节点中，此时它可以将请求发送到任意节点，这里它将请求转发到NODE2。</p>
<p>3）NODE2将文档返回给 NODE1,NODE1将文档返回给客户端。</p>
<p>NODE1作为协调节点，会将客户端请求轮询发送到集群的所有副本来实现负载均衡。</p>
<p><img src="E:\blog\blog\source_posts\image\es-18.png" alt="es-18"></p>
<h3 id="2-3-集群部署规划"><a href="#2-3-集群部署规划" class="headerlink" title="2.3 集群部署规划"></a>2.3 集群部署规划</h3><p>准备一台虚拟机：</p>
<p>ip： node1 （节点一）,  端口：9200， 9300</p>
<p>ip： node2 （节点二），端口：9201， 9301</p>
<p>ip： node3 （节点三），端口：9202， 9302</p>
<h3 id="2-4-集群配置"><a href="#2-4-集群配置" class="headerlink" title="2.4 集群配置"></a>2.4 集群配置</h3><h4 id="2-4-1-下载安装包"><a href="#2-4-1-下载安装包" class="headerlink" title="2.4.1 下载安装包"></a>2.4.1 下载安装包</h4><p>下载最新版ElasticSearch7.10.2： <a target="_blank" rel="noopener" href="https://www.elastic.co/cn/start">https://www.elastic.co/cn/start</a></p>
<h4 id="2-4-2-解压安装包"><a href="#2-4-2-解压安装包" class="headerlink" title="2.4.2 解压安装包"></a>2.4.2 解压安装包</h4><p>将安装包解压至/opt/elasticsearch/cluster目录</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p &#x2F;opt&#x2F;elasticsearch&#x2F;cluster
cd &#x2F;opt&#x2F;elasticsearch&#x2F;cluster
tar -xvf elasticsearch-7.10.2-linux-x86_64.tar.gz</code></pre>

<h4 id="2-4-3-修改集群配置文件"><a href="#2-4-3-修改集群配置文件" class="headerlink" title="2.4.3 修改集群配置文件"></a>2.4.3 修改集群配置文件</h4><p>vi node1/config/elasticsearch.yml</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 集群名称
cluster.name: my-application
#节点名称
node.name: node-1
# 绑定IP地址
network.host: 192.168.10.30
# 指定服务访问端口
http.port: 9200
# 指定API端户端调用端口
transport.tcp.port: 9300
#集群通讯地址
discovery.seed_hosts: [&quot;192.168.10.30:9300&quot;, &quot;192.168.10.30:9301&quot;,&quot;192.168.10.30:9302&quot;]
#集群初始化能够参选的节点信息
cluster.initial_master_nodes: [&quot;192.168.10.30:9300&quot;, &quot;192.168.10.30:9301&quot;,&quot;192.168.10.30:9302&quot;]
#开启跨域访问支持，默认为false
http.cors.enabled: true
##跨域访问允许的域名, 允许所有域名
http.cors.allow-origin: &quot;*&quot;
</code></pre>

<p>修改目录权限</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chown -R elsearch:elsearch &#x2F;opt&#x2F;elasticsearch&#x2F;cluster&#x2F;node1</code></pre>

<h4 id="2-4-4-创建其余两个节点"><a href="#2-4-4-创建其余两个节点" class="headerlink" title="2.4.4 创建其余两个节点"></a>2.4.4 创建其余两个节点</h4><p>复制node1安装目录：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;opt&#x2F;elasticsearch&#x2F;cluster
cp -r node1 node2
cp -r node1 node3</code></pre>

<h4 id="2-4-5-修改其余节点的配置"><a href="#2-4-5-修改其余节点的配置" class="headerlink" title="2.4.5 修改其余节点的配置"></a>2.4.5 修改其余节点的配置</h4><p>1）node2节点配置内容</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 集群名称
cluster.name: my-application
#节点名称
node.name: node-2
# 绑定IP地址
network.host: 192.168.10.30
# 指定服务访问端口
http.port: 9201
# 指定API端户端调用端口
transport.tcp.port: 9301
#集群通讯地址
discovery.seed_hosts: [&quot;192.168.10.30:9300&quot;, &quot;192.168.10.30:9301&quot;,&quot;192.168.10.30:9302&quot;]
#集群初始化能够参选的节点信息
cluster.initial_master_nodes: [&quot;192.168.10.30:9300&quot;, &quot;192.168.10.30:9301&quot;,&quot;192.168.10.30:9302&quot;]
#开启跨域访问支持，默认为false
http.cors.enabled: true
##跨域访问允许的域名, 允许所有域名
http.cors.allow-origin: &quot;*&quot;
</code></pre>

<p>2）node3节点配置内容</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 集群名称
cluster.name: my-application
#节点名称
node.name: node-3
# 绑定IP地址
network.host: 192.168.10.30
# 指定服务访问端口
http.port: 9202
# 指定API端户端调用端口
transport.tcp.port: 9302
#集群通讯地址
discovery.seed_hosts: [&quot;192.168.10.30:9300&quot;, &quot;192.168.10.30:9301&quot;,&quot;192.168.10.30:9302&quot;]
#集群初始化能够参选的节点信息
cluster.initial_master_nodes: [&quot;192.168.10.30:9300&quot;, &quot;192.168.10.30:9301&quot;,&quot;192.168.10.30:9302&quot;]
#开启跨域访问支持，默认为false
http.cors.enabled: true
##跨域访问允许的域名, 允许所有域名
http.cors.allow-origin: &quot;*&quot;</code></pre>

<h4 id="2-4-6-启动集群节点"><a href="#2-4-6-启动集群节点" class="headerlink" title="2.4.6 启动集群节点"></a>2.4.6 启动集群节点</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 切换elsearch用户
su elsearch
## 分别启动三个ES服务
&#x2F;opt&#x2F;elasticsearch&#x2F;cluster&#x2F;node1&#x2F;bin&#x2F;elasticsearch -d
&#x2F;opt&#x2F;elasticsearch&#x2F;cluster&#x2F;node2&#x2F;bin&#x2F;elasticsearch -d
&#x2F;opt&#x2F;elasticsearch&#x2F;cluster&#x2F;node3&#x2F;bin&#x2F;elasticsearch -d</code></pre>

<p>注意： 如果启动出现错误， 将各节点的data目录清空， 再重启服务。</p>
<h4 id="2-4-7-集群状态查看"><a href="#2-4-7-集群状态查看" class="headerlink" title="2.4.7 集群状态查看"></a>2.4.7 集群状态查看</h4><p><a target="_blank" rel="noopener" href="http://192.168.10.30:9200/_cat/nodes?pretty">http://192.168.10.30:9200/_cat/nodes?pretty</a></p>
<p>可以看到三个节点信息，三个节点会自行选举出主节点。</p>
<h3 id="2-5-集群分片测试"><a href="#2-5-集群分片测试" class="headerlink" title="2.5 集群分片测试"></a>2.5 集群分片测试</h3><h4 id="2-5-1-修改kibana配置"><a href="#2-5-1-修改kibana配置" class="headerlink" title="2.5.1 修改kibana配置"></a>2.5.1 修改kibana配置</h4><pre class="line-numbers language-none"><code class="language-none">elasticsearch.hosts: [&quot;http:&#x2F;&#x2F;192.168.10.30:9200&quot;,&quot;http:&#x2F;&#x2F;192.168.10.30:9201&quot;,&quot;http:&#x2F;&#x2F;192.168.10.30:9202&quot;]</code></pre>

<p>重启kibana服务， 进入控制台：<a target="_blank" rel="noopener" href="http://192.168.10.30:5601/app/home#/">http://192.168.10.30:5601/app/home#/</a></p>
<h4 id="2-5-2-设置分片数"><a href="#2-5-2-设置分片数" class="headerlink" title="2.5.2 设置分片数"></a>2.5.2 设置分片数</h4><p>1）2个主分片、2个副分片</p>
<pre class="line-numbers language-none"><code class="language-none">## 再次创建索引（副本数量范围内）
PUT orders
&#123;
    &quot;settings&quot;: &#123;
        &quot;index&quot;: &#123;
            &quot;number_of_shards&quot;: 2,
            &quot;number_of_replicas&quot;: 2
        &#125;
    &#125;
&#125;</code></pre>

<p>结果正常：</p>
<p><img src="E:\blog\blog\source_posts\image\es-19.png" alt="es-19"></p>
<p>2）2个主分片、5个副分片</p>
<pre class="line-numbers language-none"><code class="language-none">PUT orders
&#123;
    &quot;settings&quot;: &#123;
        &quot;index&quot;: &#123;
            &quot;number_of_shards&quot;: 2,
            &quot;number_of_replicas&quot;: 5
        &#125;
    &#125;
&#125;</code></pre>

<p>yellow警告错误：</p>
<p><img src="E:\blog\blog\source_posts\image\es-20.png" alt="es-20"></p>
<h4 id="2-5-3-分片设置总结"><a href="#2-5-3-分片设置总结" class="headerlink" title="2.5.3 分片设置总结"></a>2.5.3 分片设置总结</h4><p>集群并非可以随意增加副本数量</p>
<h2 id="3-ELK部署应用与工作机制"><a href="#3-ELK部署应用与工作机制" class="headerlink" title="3. ELK部署应用与工作机制"></a>3. ELK部署应用与工作机制</h2><h3 id="3-1-ELK日志分析平台介绍"><a href="#3-1-ELK日志分析平台介绍" class="headerlink" title="3.1 ELK日志分析平台介绍"></a>3.1 ELK日志分析平台介绍</h3><h2 id="4-ElasticSearch高阶操作"><a href="#4-ElasticSearch高阶操作" class="headerlink" title="4. ElasticSearch高阶操作"></a>4. ElasticSearch高阶操作</h2><h3 id="4-1-SpringBoot整合ES"><a href="#4-1-SpringBoot整合ES" class="headerlink" title="4.1 SpringBoot整合ES"></a>4.1 SpringBoot整合ES</h3><p>1）依赖的引入</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- elasticsearch--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;&#x2F;artifactId&gt;
    &lt;version&gt;7.10.2&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;elasticsearch-rest-client&lt;&#x2F;artifactId&gt;
    &lt;version&gt;7.10.2&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;elasticsearch&lt;&#x2F;artifactId&gt;
    &lt;version&gt;7.10.2&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>2）ESConfig连接配置类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ConfigurationProperties(prefix &#x3D; &quot;elasticsearch&quot;)
public class ESConfig &#123;

    private String host;

    private int port;


    public String getHost() &#123;
        return host;
    &#125;

    public void setHost(String host) &#123;
        this.host &#x3D; host;
    &#125;

    public int getPort() &#123;
        return port;
    &#125;

    public void setPort(int port) &#123;
        this.port &#x3D; port;
    &#125;

    &#x2F;**
     * es java客户端
     *
     * @return
     *&#x2F;
    @Bean
    public RestHighLevelClient restHighLevelClient() &#123;
        RestClientBuilder builder &#x3D; RestClient.builder(new HttpHost(host, port, &quot;http&quot;));
        builder.setRequestConfigCallback(requestConfigBuilder -&gt; &#123;
            requestConfigBuilder.setConnectionRequestTimeout(500000);
            requestConfigBuilder.setSocketTimeout(500000);
            requestConfigBuilder.setConnectTimeout(500000);
            return requestConfigBuilder;
        &#125;);
        return new RestHighLevelClient(builder);
    &#125;
&#125;</code></pre>

<h3 id="4-2-倒排索引"><a href="#4-2-倒排索引" class="headerlink" title="4.2 倒排索引"></a>4.2 倒排索引</h3><h4 id="4-2-1-概念"><a href="#4-2-1-概念" class="headerlink" title="4.2.1 概念"></a>4.2.1 概念</h4><p>要想理解倒排索引，首先先思考一个问题，获取某个文件夹下所有文件名中包含Spring的文件</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">1）确定要搜索的文件夹
2）遍历文件夹下所有文件
3）判断文件名中是否包含Spring</code></pre>

<p>这种思维可以理解为是一种正向思维的方式，从外往内，根据key找value。这种方式可以理解为正向索引。</p>
<h4 id="4-2-2-结构"><a href="#4-2-2-结构" class="headerlink" title="4.2.2 结构"></a>4.2.2 结构</h4><p>而ElasticSearch为了提升查询效率，采用反向思维方式，根据value找key。</p>
<p><img src="E:\blog\blog\source_posts\image\es-21.png" alt="es-21"></p>
<h3 id="4-3-IK分词器"><a href="#4-3-IK分词器" class="headerlink" title="4.3 IK分词器"></a>4.3 IK分词器</h3><h4 id="4-3-1-认识分词器"><a href="#4-3-1-认识分词器" class="headerlink" title="4.3.1 认识分词器"></a>4.3.1 认识分词器</h4><p>查询出了很多万豪相关的酒店，现在以<code>北京市东城区万豪酒店</code>查询name域，可以发现无法查询到结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">GET hotel&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;term&quot;: &#123;
      &quot;name&quot;: &quot;北京市东城区万豪酒店&quot;
    &#125;
  &#125;
&#125;

MySQL [elasticsearch_db]&gt; select * from t_hotel where name &#x3D; &#39;北京市东城区万豪酒店&#39; \G;]</code></pre>

<p>在创建索引时，对于name域，数据类型是<code>text</code>。当添加文档时，对于该域的值会进行分词，形成若干term（词条）存储在倒排索引中。</p>
<p>根据倒排索引结构，当查询条件在词条中存在，则会查询到数据。如果词条中没有，则查询不到数据。</p>
<p>那么对于<code>北京市东城区万豪酒店</code>的分词结果是什么呢？</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">GET hotel&#x2F;_analyze
&#123;
 &quot;field&quot;: &quot;name&quot;,  
  &quot;text&quot;: &quot;北京市东城区万豪酒店&quot;
&#125;

GET hotel&#x2F;_analyze
&#123;
  &quot;field&quot;: &quot;name&quot;, 
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;北京市东城区万豪酒店&quot;
&#125;

GET _analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_smart&quot;,
  &quot;text&quot;: &quot;北京市东城区万豪酒店&quot;
&#125;

GET _analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;北京市东城区万豪酒店&quot;
&#125;</code></pre>

<p>此时可以发现，每个字形成了一个词，所以并没有找到相匹配的词，导致无法查询到结果</p>
<p>在ElasticSearch默认内置了多种分词器：</p>
<ul>
<li><strong>Standard Analyzer</strong> - 默认分词器，按英文空格切分 </li>
<li>Simple Analyzer - 按照非字母切分(符号被过滤)</li>
<li>Stop Analyzer - 小写处理，停用词过滤(the,a,is) </li>
<li>Whitespace Analyzer - 按照空格切分，不转小写 </li>
<li>Keyword Analyzer - 不分词，直接将输入当作输出 </li>
<li>Patter Analyzer - 正则表达式，默认\W+(非字符分割) </li>
</ul>
<p>而我们想要的是，分词器能够智能的将中文按照词义分成若干个有效的词。此时就需要额外安装中文分词器。 对于中文分词器的类型也有很多，其中首选的是：IK分词器。</p>
<h4 id="4-3-2-安装IK分词器"><a href="#4-3-2-安装IK分词器" class="headerlink" title="4.3.2 安装IK分词器"></a>4.3.2 安装IK分词器</h4><p>1）安装IK分词插件</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.10.2/elasticsearch-analysis-ik-7.10.2.zip">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.10.2/elasticsearch-analysis-ik-7.10.2.zip</a></p>
<p>2）采用本地文件安装方式， 进入ES安装目录， 执行插件安装命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@linux30 cluster]# .&#x2F;node1&#x2F;bin&#x2F;elasticsearch-plugin install file:&#x2F;&#x2F;&#x2F;opt&#x2F;elasticsearch&#x2F;elasticsearch-analysis-ik-7.10.2.zip
[root@linux30 cluster]# .&#x2F;node2&#x2F;bin&#x2F;elasticsearch-plugin install file:&#x2F;&#x2F;&#x2F;opt&#x2F;elasticsearch&#x2F;elasticsearch-analysis-ik-7.10.2.zip
[root@linux30 cluster]# .&#x2F;node3&#x2F;bin&#x2F;elasticsearch-plugin install file:&#x2F;&#x2F;&#x2F;opt&#x2F;elasticsearch&#x2F;elasticsearch-analysis-ik-7.10.2.zip</code></pre>

<p>安装成功后， 会给出对应提示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-&gt; Installing file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;elasticsearch-7.10.2&#x2F;elasticsearch-analysis-ik-7.10.2.zip
-&gt; Downloading file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;elasticsearch-7.10.2&#x2F;elasticsearch-analysis-ik-7.10.2.zip
[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 100%   
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@     WARNING: plugin requires additional permissions     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
* java.net.SocketPermission * connect,resolve
See http:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;technotes&#x2F;guides&#x2F;security&#x2F;permissions.html
for descriptions of what these permissions allow and the associated risks.

Continue with installation? [y&#x2F;N]y
-&gt; Installed analysis-ik</code></pre>

<p>3）重启ElasticSearch服务</p>
<h4 id="4-3-3-测试IK分词器"><a href="#4-3-3-测试IK分词器" class="headerlink" title="4.3.3 测试IK分词器"></a>4.3.3 测试IK分词器</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## standard标准分词器
GET _analyze
&#123;
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;北京市东城区万豪酒店&quot;
&#125;
## IK智能化分词器
GET _analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_smart&quot;,
  &quot;text&quot;: &quot;北京市东城区万豪酒店&quot;
&#125;
## ik_max_word最大化分词
GET _analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;北京市东城区万豪酒店&quot;
&#125;</code></pre>

<h4 id="4-3-4-IK分词器最佳运用"><a href="#4-3-4-IK分词器最佳运用" class="headerlink" title="4.3.4 IK分词器最佳运用"></a>4.3.4 IK分词器最佳运用</h4><p>analyzer指定的是构建索引的分词，search_analyzer指定的是搜索关键字的分词。</p>
<p>实践运用的时候， 构建索引的时候采用max_word，将分词最大化； 查询的时候则使用smartword智能化分词，这样能够最大程度的匹配出结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PUT hotel
&#123;
  &quot;settings&quot;: &#123;
    &quot;number_of_shards&quot;: 1,
    &quot;number_of_replicas&quot;: 0
  &#125;, 
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
        &quot;search_analyzer&quot;:&quot;ik_smart&quot;
      &#125;,
      &quot;address&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;,
      &quot;brand&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;type&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
       &quot;price&quot;:&#123;
        &quot;type&quot;: &quot;integer&quot;
      &#125;,
      &quot;specs&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
       &quot;salesVolume&quot;:&#123;
        &quot;type&quot;: &quot;integer&quot;
      &#125;,
      &quot;area&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
        &quot;search_analyzer&quot;:&quot;ik_smart&quot;
      &#125;,
      &quot;imageUrl&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;,
      &quot;synopsis&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;,
      &quot;createTime&quot;:&#123;
        &quot;type&quot;: &quot;date&quot;,
        &quot;format&quot;: &quot;yyyy-MM-dd&quot;
      &#125;,
      &quot;isAd&quot;:&#123;
        &quot;type&quot;:&quot;integer&quot;
      &#125;
    &#125;
  &#125;
&#125;</code></pre>

<h4 id="4-3-5-自定义扩展词、停用词"><a href="#4-3-5-自定义扩展词、停用词" class="headerlink" title="4.3.5 自定义扩展词、停用词"></a>4.3.5 自定义扩展词、停用词</h4><p>1）编辑 IKAnalyzer.cfg.xml文件，配置自定义扩展词 my_ext.dic 和 停用词 my_stopword.dic。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">[root@linux30 cluster]# cat node1&#x2F;config&#x2F;analysis-ik&#x2F;IKAnalyzer.cfg.xml
&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;properties.dtd&quot;&gt;
&lt;properties&gt;
        &lt;comment&gt;IK Analyzer 扩展配置&lt;&#x2F;comment&gt;
        &lt;!--用户可以在这里配置自己的扩展字典 --&gt;
        &lt;entry key&#x3D;&quot;ext_dict&quot;&gt;my_ext.dic&lt;&#x2F;entry&gt;
         &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;
        &lt;entry key&#x3D;&quot;ext_stopwords&quot;&gt;my_stopword.dic&lt;&#x2F;entry&gt;
        &lt;!--用户可以在这里配置远程扩展字典 --&gt;
        &lt;!-- &lt;entry key&#x3D;&quot;remote_ext_dict&quot;&gt;words_location&lt;&#x2F;entry&gt; --&gt;
        &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;
        &lt;!-- &lt;entry key&#x3D;&quot;remote_ext_stopwords&quot;&gt;words_location&lt;&#x2F;entry&gt; --&gt;
&lt;&#x2F;properties&gt;
[root@linux30 cluster]#
</code></pre>

<p>2）创建 my_ext.dic 和 my_stopword.dic</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@linux30 cluster]# vi node1&#x2F;config&#x2F;analysis-ik&#x2F;my_ext.dic
## 添加如下内容
我爱我的祖国
[root@linux30 cluster]# vi node1&#x2F;config&#x2F;analysis-ik&#x2F;my_stopword.dic
## 添加如下内容
祖国</code></pre>

<p>3）只需要重启node1节点即可</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 分词验证
GET _analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_smart&quot;,
  &quot;text&quot;: &quot;我爱我的祖国&quot;
&#125;
## 返回结果：
&#123;
  &quot;tokens&quot; : [
    &#123;
      &quot;token&quot; : &quot;我爱我的祖国&quot;,
      &quot;start_offset&quot; : 0,
      &quot;end_offset&quot; : 6,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 0
    &#125;
  ]
&#125;</code></pre>



<h3 id="4-4-基础查询"><a href="#4-4-基础查询" class="headerlink" title="4.4 基础查询"></a>4.4 基础查询</h3><h4 id="4-4-1-查询所有酒店信息"><a href="#4-4-1-查询所有酒店信息" class="headerlink" title="4.4.1 查询所有酒店信息"></a>4.4.1 查询所有酒店信息</h4><p>match_all</p>
<pre class="line-numbers language-none"><code class="language-none">## 查询所有酒店
GET hotel&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;
&#125;</code></pre>

<h4 id="4-4-2-分页查询酒店列表"><a href="#4-4-2-分页查询酒店列表" class="headerlink" title="4.4.2 分页查询酒店列表"></a>4.4.2 分页查询酒店列表</h4><p>from：从哪开始</p>
<p>size：查询条数</p>
<pre class="line-numbers language-none"><code class="language-none">## 分页查询酒店列表
GET hotel&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;,
  &quot;from&quot;: 0,
  &quot;size&quot;: 5
&#125;</code></pre>

<h4 id="4-4-3-品牌精确搜索"><a href="#4-4-3-品牌精确搜索" class="headerlink" title="4.4.3 品牌精确搜索"></a>4.4.3 品牌精确搜索</h4><p>term：不会对查询条件进行分词</p>
<pre class="line-numbers language-none"><code class="language-none">## 展示出&quot;万豪&quot;品牌下的所有酒店信息
GET hotel&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;term&quot;: &#123;
      &quot;brand&quot;: &quot;万豪&quot;
    &#125;
  &#125;
&#125;</code></pre>

<h4 id="4-4-4-酒店名称分词查询"><a href="#4-4-4-酒店名称分词查询" class="headerlink" title="4.4.4 酒店名称分词查询"></a>4.4.4 酒店名称分词查询</h4><p>matchQuery会对查询条件进行分词</p>
<pre class="line-numbers language-none"><code class="language-none">## 酒店名称分词查询
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;name&quot;: &quot;北京市东城区瑞麟湾酒店&quot;
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-4-5-酒店品牌模糊搜索"><a href="#4-4-5-酒店品牌模糊搜索" class="headerlink" title="4.4.5 酒店品牌模糊搜索"></a>4.4.5 酒店品牌模糊搜索</h4><p>wildcard：不会对查询条件进行分词。还可以使用通配符 ?（任意单个字符） 和  * （0个或多个字符）</p>
<pre class="line-numbers language-none"><code class="language-none">## 酒店品牌模糊搜索
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;wildcard&quot;: &#123;
            &quot;brand&quot;: &quot;万*&quot;
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-4-6-多域搜索"><a href="#4-4-6-多域搜索" class="headerlink" title="4.4.6 多域搜索"></a>4.4.6 多域搜索</h4><p>queryStringQuery：可以指定多个域、会对搜索条件分词、将分词后的搜索条件与term匹配、取结果并集OR、交集AND</p>
<pre class="line-numbers language-none"><code class="language-none">## 多域搜索
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;query_string&quot;: &#123;
            &quot;fields&quot;: [&quot;name&quot;, &quot;address&quot;, &quot;area&quot;, &quot;synopsis&quot;],
            &quot;query&quot;: &quot;spa OR 商务&quot;
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-4-7-销量排序搜索-sort"><a href="#4-4-7-销量排序搜索-sort" class="headerlink" title="4.4.7 销量排序搜索 sort"></a>4.4.7 销量排序搜索 sort</h4><p>order: asc升序 或 desc降序</p>
<pre class="line-numbers language-none"><code class="language-none">## 销量排序
GET hotel&#x2F;_search
&#123;
    &quot;sort&quot;: &#123;
        &quot;salesVolume&quot;: &#123;
            &quot;order&quot;: &quot;asc&quot;
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-4-8-价格范围搜索"><a href="#4-4-8-价格范围搜索" class="headerlink" title="4.4.8  价格范围搜索"></a>4.4.8  价格范围搜索</h4><p>range: gt 大于、gte 大于等于、 lt 小于、lte 小于等于</p>
<pre class="line-numbers language-none"><code class="language-none">## 价格范围搜索
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;range&quot;: &#123;
            &quot;price&quot;: &#123;
                &quot;gte&quot;: 600,
                &quot;lt&quot;: 1600
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-4-9-自动纠错搜索"><a href="#4-4-9-自动纠错搜索" class="headerlink" title="4.4.9 自动纠错搜索"></a>4.4.9 自动纠错搜索</h4><p>fuzzyQuery：自动尝试将条件纠错，并和词条匹配、fuzziness 允许对几个字进行纠错、prefix_length 设置前几个字符不允许编辑</p>
<p>在未经处理的情况下，一旦条件存在错别字，找不到term，则无法查询到结果</p>
<pre class="line-numbers language-none"><code class="language-none">## 正常搜索
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;term&quot;: &#123;
           &quot;area&quot;: &quot;北京市&quot;
       &#125;
    &#125;
&#125;
## 错别字 经
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;term&quot;: &#123;
           &quot;area&quot;: &quot;北经市&quot;
       &#125;
    &#125;
&#125;
## 自动纠错搜索 经
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
      &quot;fuzzy&quot;: &#123;
        &quot;area&quot;: &#123;
          &quot;fuzziness&quot;: 1,
          &quot;prefix_length&quot;: 1,
          &quot;value&quot;: &quot;北经市&quot;
        &#125;
      &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-4-10-搜索结果高亮显示"><a href="#4-4-10-搜索结果高亮显示" class="headerlink" title="4.4.10 搜索结果高亮显示"></a>4.4.10 搜索结果高亮显示</h4><p>highlight：如需将搜索条件以高亮形式展示，则需要在查询时，设置需要对哪一个域以何种样式进行展示，fields 设置要对哪个域高亮、pre_tags 设置高亮样式前缀、post_tags 设置高亮样式后缀</p>
<pre class="line-numbers language-none"><code class="language-none">GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;term&quot;: &#123;
           &quot;name&quot;: &quot;新乐&quot;
       &#125;
    &#125;,
    &quot;highlight&quot;: &#123;
        &quot;fields&quot;: &#123;
            &quot;name&quot;: &#123;
                &quot;pre_tags&quot;: &quot;&lt;font color&#x3D;&#39;red&#39;&gt;&quot;,
                &quot;post_tags&quot;: &quot;&lt;&#x2F;font&gt;&quot;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="4-5-bool查询"><a href="#4-5-bool查询" class="headerlink" title="4.5 bool查询"></a>4.5 bool查询</h3><p>boolQuery:  对多个查询条件拼接、must（and）条件必须成立、must_not （not）条件必须不成立、should（or）条件可以成立、filter 条件过滤，必须成立</p>
<h4 id="4-5-1-must"><a href="#4-5-1-must" class="headerlink" title="4.5.1 must"></a>4.5.1 must</h4><pre class="line-numbers language-none"><code class="language-none">## must单独使用 品牌必须是万豪，地区必须是北京市
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: [
                &#123;
                   &quot;term&quot;: &#123;
                        &quot;brand&quot;: &quot;万豪&quot;
                    &#125;
                &#125;,&#123;
                    &quot;term&quot;: &#123;
                        &quot;area&quot;: &quot;北京市&quot;
                    &#125;
                &#125;
            ]
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-5-2-filter"><a href="#4-5-2-filter" class="headerlink" title="4.5.2 filter"></a>4.5.2 filter</h4><pre class="line-numbers language-none"><code class="language-none">## filter单独使用 
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;filter&quot;: [
                &#123;
                    &quot;term&quot;: &#123;
                         &quot;brand&quot;: &quot;万豪&quot;
                    &#125;
                &#125;,&#123;
                    &quot;term&quot;: &#123;
                        &quot;area&quot;: &quot;北京市&quot;
                    &#125;
                &#125;
            ]
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-5-3-must和filter组合使用"><a href="#4-5-3-must和filter组合使用" class="headerlink" title="4.5.3 must和filter组合使用"></a>4.5.3 must和filter组合使用</h4><pre class="line-numbers language-none"><code class="language-none">## must和filter组合使用 品牌为万豪下的，地区为北京市、价格范围在500和2000之间的酒店
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: [
                &#123;
                   &quot;term&quot;: &#123;
                        &quot;brand&quot;: &quot;万豪&quot;
                    &#125;
                &#125;
            ],
            &quot;filter&quot;: [
                &#123;
                    &quot;term&quot;: &#123;
                        &quot;area&quot;: &quot;北京市&quot;
                    &#125;
                &#125;,&#123;
                    &quot;range&quot;: &#123;
                        &quot;price&quot;: &#123;
                            &quot;gte&quot;: 500,
                            &quot;lte&quot;: 2000
                        &#125;
                    &#125;
                &#125;
            ]
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="4-6-聚合查询"><a href="#4-6-聚合查询" class="headerlink" title="4.6 聚合查询"></a>4.6 聚合查询</h3><p>聚合介绍：在MySQL中提供了许多聚合函数，如max、min、avg、count等。并且也提供了分组实现group by。对于这些功能，在es中同样提供，主要用于对数据统计分析。</p>
<p>ES中的聚合搜索分为两类：指标聚合、桶聚合</p>
<p>指标聚合：如max、min、sum等。作用等同MySQL中相关聚合函数</p>
<p>桶聚合：用于数据分组，作用等同于MySQL中的group by。</p>
<p>ps：不能对Text类型分组，因为会分词。</p>
<h4 id="4-6-1-指标聚合"><a href="#4-6-1-指标聚合" class="headerlink" title="4.6.1 指标聚合"></a>4.6.1 指标聚合</h4><pre class="line-numbers language-none"><code class="language-none">## 统计品牌为万豪下最贵酒店价格
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;term&quot;: &#123;
           &quot;brand&quot;: &quot;万豪&quot;
       &#125;
    &#125;,
    &quot;aggs&quot;: &#123;
        &quot;my_max_price&quot;: &#123;
            &quot;max&quot;: &#123;
                &quot;field&quot;: &quot;price&quot;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-6-2-桶聚合"><a href="#4-6-2-桶聚合" class="headerlink" title="4.6.2 桶聚合"></a>4.6.2 桶聚合</h4><p>1）统计品牌为万豪下有哪些星级</p>
<pre class="line-numbers language-none"><code class="language-none">## 统计品牌为万豪下有哪些星级
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;term&quot;: &#123;
           &quot;brand&quot;: &quot;万豪&quot;
       &#125;
    &#125;,
    &quot;aggs&quot;: &#123;
        &quot;my_group&quot;: &#123;
            &quot;terms&quot;: &#123;
                &quot;field&quot;: &quot;specs&quot;,
                &quot;size&quot;: 5
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>2）根据搜索条件对品牌分组</p>
<pre class="line-numbers language-none"><code class="language-none">## 根据搜索条件对品牌分组
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;query_string&quot;: &#123;
           &quot;fields&quot;: [&quot;name&quot;, &quot;synopsis&quot;, &quot;area&quot;, &quot;address&quot;],
           &quot;query&quot;: &quot;三亚 OR 商务&quot;
       &#125;
    &#125;,
    &quot;aggs&quot;: &#123;
        &quot;hotel_brand&quot;: &#123;
            &quot;terms&quot;: &#123;
                &quot;field&quot;: &quot;brand&quot;,
                &quot;size&quot;: 100
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h4 id="4-6-3-示例"><a href="#4-6-3-示例" class="headerlink" title="4.6.3 示例"></a>4.6.3 示例</h4><pre class="line-numbers language-none"><code class="language-none">## 自定义时间段统计某品牌下酒店销量
GET hotel&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;range&quot;: &#123;
      &quot;createTime&quot;: &#123;
        &quot;gte&quot;: &quot;2016-01-01&quot;,
        &quot;lte&quot;: &quot;2021-01-01&quot;
      &#125;
    &#125;
  &#125;,
  &quot;aggs&quot;: &#123;
    &quot;hotel_brand&quot;: &#123;
      &quot;terms&quot;: &#123;
        &quot;field&quot;: &quot;brand&quot;,
        &quot;size&quot;: 100
      &#125;,
      &quot;aggs&quot;: &#123;
        &quot;sale_count&quot;: &#123;
          &quot;sum&quot;: &#123;
            &quot;field&quot;: &quot;salesVolume&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;</code></pre>



<h2 id="5-ElasticSearch实战技巧"><a href="#5-ElasticSearch实战技巧" class="headerlink" title="5. ElasticSearch实战技巧"></a>5. ElasticSearch实战技巧</h2><h3 id="5-1-优化多字段查询"><a href="#5-1-优化多字段查询" class="headerlink" title="5.1 优化多字段查询"></a>5.1 优化多字段查询</h3><p>搜索时，对于每条搜索结果ES都会对其按照匹配度进行打分，分数越高，在结果中排名越靠前。</p>
<p>在ES中提供了两种设置权重的方式：索引设置、查询设置。</p>
<p>索引设置：创建索引时配置权重，该方式应用较少，因为一旦需求发生改变，则需要重新创建索引。</p>
<p>查询设置：在查询时，根据需求灵活的配置权重，该方式使用最多。</p>
<h4 id="5-1-1-提升字段查询得分"><a href="#5-1-1-提升字段查询得分" class="headerlink" title="5.1.1 提升字段查询得分"></a>5.1.1 提升字段查询得分</h4><p>将name字段查询比重提升10倍</p>
<pre class="line-numbers language-none"><code class="language-none">GET hotel&#x2F;_search
&#123;
  &quot;explain&quot;: true, 
  &quot;query&quot;:&#123;
    &quot;multi_match&quot;:&#123;
      &quot;query&quot;: &quot;北京金龙&quot;,
      &quot;fields&quot;: [&quot;name^10&quot;, &quot;address&quot;]
    &#125;
  &#125;
&#125;</code></pre>

<h4 id="5-1-2-综合提升字段查询得分"><a href="#5-1-2-综合提升字段查询得分" class="headerlink" title="5.1.2 综合提升字段查询得分"></a>5.1.2 综合提升字段查询得分</h4><p>tie_breaker：将其他query的分数也考虑进去（最大值加上其他值的0.3倍）</p>
<pre class="line-numbers language-none"><code class="language-none">GET hotel&#x2F;_search
&#123;
  &quot;explain&quot;: true, 
  &quot;query&quot;:&#123;
    &quot;multi_match&quot;:&#123;
      &quot;query&quot;: &quot;北京金龙&quot;,
      &quot;fields&quot;: [&quot;name&quot;, &quot;address&quot;],
      &quot;tie_breaker&quot;: 0.3
    &#125;
  &#125;
&#125;</code></pre>

<p>使用 tie_breaker 和不使用tie_breaker ，查询出来的某一条数据的 _score 分数，会有相应的提高，例如：</p>
<blockquote>
<p>name中包含关键词matched query 的得分，假设是 0.1984226</p>
<p>address中包含关键词matched query的得分，假设是 12.07466</p>
</blockquote>
<p>添加了 tie_breaker = 0.3，那么就是这样的了， 0.1984226 * 0.3 + 12.07466 = 12.13418678；</p>
<p>大于最高一条的得分12.07466，这样搜索的关联性就提升上去了， 更为合理。</p>
<h4 id="5-1-3-自定义评分"><a href="#5-1-3-自定义评分" class="headerlink" title="5.1.3 自定义评分"></a>5.1.3 自定义评分</h4><p>1）创建索引时设置权重</p>
<pre class="line-numbers language-none"><code class="language-none">## 查询多域展示相关结果数据
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;query_string&quot;: &#123;
           &quot;fields&quot;: [&quot;name&quot;, &quot;synopsis&quot;, &quot;area&quot;, &quot;address&quot;],
           &quot;query&quot;: &quot;北京市万豪spa三星&quot;
       &#125;
    &#125;
&#125;

## 评分扩大10倍
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;query_string&quot;: &#123;
           &quot;fields&quot;: [&quot;name&quot;, &quot;synopsis&quot;, &quot;area&quot;, &quot;address&quot;],
           &quot;query&quot;: &quot;北京市万豪spa三星&quot;,
           &quot;boost&quot;: 10
       &#125;
    &#125;
&#125;</code></pre>

<p>2）查询设置权重</p>
<p>function_score</p>
<pre class="line-numbers language-none"><code class="language-none">## 为品牌为万豪的酒店，权重值增加50倍
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
       &quot;function_score&quot;: &#123;
           &quot;query&quot;: &#123;
               &quot;query_string&quot;: &#123;
                    &quot;fields&quot;: [&quot;name&quot;, &quot;synopsis&quot;, &quot;area&quot;, &quot;address&quot;],
                     &quot;query&quot;: &quot;北京市万豪spa三星&quot;
               &#125;
           &#125;,
           &quot;functions&quot;: [
               &#123;
                   &quot;filter&quot;: &#123;
                       &quot;term&quot;: &#123;
                           &quot;brand&quot;: &quot;万豪&quot;
                       &#125;
                   &#125;,
                   &quot;weight&quot;: 50
               &#125;
           ]
       &#125;
    &#125;
&#125;
## 将广告酒店的权重增加100倍，使其靠前
GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;function_score&quot;: &#123;
            &quot;query&quot;: &#123;
                &quot;query_string&quot;: &#123;
                    &quot;fields&quot;: [&quot;name&quot;, &quot;synopsis&quot;, &quot;area&quot;, &quot;address&quot;],
                    &quot;query&quot;: &quot;北京市万豪spa三星&quot;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

GET hotel&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;function_score&quot;: &#123;
            &quot;query&quot;: &#123;
                &quot;query_string&quot;: &#123;
                    &quot;fields&quot;: [&quot;name&quot;, &quot;synopsis&quot;, &quot;area&quot;, &quot;address&quot;],
                    &quot;query&quot;: &quot;北京市万豪spa三星&quot;
                &#125;
            &#125;,
            &quot;functions&quot;: [
                &#123;
                    &quot;filter&quot;: &#123;
                        &quot;term&quot;: &#123;
                            &quot;isAd&quot;: &quot;1&quot;
                        &#125;
                    &#125;,
                    &quot;weight&quot;: 100
                &#125;
            ]
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="5-2-全量索引构建"><a href="#5-2-全量索引构建" class="headerlink" title="5.2 全量索引构建"></a>5.2 全量索引构建</h3><h4 id="5-21-下载logstash"><a href="#5-21-下载logstash" class="headerlink" title="5.21 下载logstash"></a>5.21 下载logstash</h4><p>下载地址：<a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/logstash/logstash-7.10.2-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/logstash/logstash-7.10.2-linux-x86_64.tar.gz</a></p>
<h4 id="5-2-2-安装logstash-input-jdbc插件"><a href="#5-2-2-安装logstash-input-jdbc插件" class="headerlink" title="5.2.2 安装logstash-input-jdbc插件"></a>5.2.2 安装logstash-input-jdbc插件</h4><pre class="line-numbers language-none"><code class="language-none">bin&#x2F;logstash-plugin install logstash-input-jdbc</code></pre>

<h4 id="5-2-3-配置mysql驱动包"><a href="#5-2-3-配置mysql驱动包" class="headerlink" title="5.2.3 配置mysql驱动包"></a>5.2.3 配置mysql驱动包</h4><pre class="line-numbers language-none"><code class="language-none">[root@linux30 logstash-7.10.2]# mkdir mysql
[root@linux30 logstash-7.10.2]# cd mysql&#x2F;
[root@linux30 mysql]# ll
总用量 2344
-rw-r--r-- 1 root root 2397321 4月  11 14:12 mysql-connector-java-8.0.21.jar</code></pre>

<h4 id="5-2-4-配置JDBC连接"><a href="#5-2-4-配置JDBC连接" class="headerlink" title="5.2.4 配置JDBC连接"></a>5.2.4 配置JDBC连接</h4><p>创建索引数据是从mysql中通过select语句查询， 然后再通过logstash-input-jdbc的配置文件方式导入 elasticsearch中。</p>
<p>在/opt/elasticsearch/logstash-7.10.2/mysql/full-sync目录创建jdbc.conf与jdbc.sql文件。</p>
<p>jdbc.conf文件：</p>
<pre class="line-numbers language-none"><code class="language-none">input &#123;
    stdin &#123;
    &#125;
    jdbc &#123;
        # mysql 数据库链接,users为数据库名
        jdbc_connection_string &#x3D;&gt; &quot;jdbc:mysql:&#x2F;&#x2F;192.168.10.30:3306&#x2F;elasticsearch_db&quot;
        # 用户名和密码
        jdbc_user &#x3D;&gt; &quot;root&quot;
        jdbc_password &#x3D;&gt; &quot;123456&quot;
        # 驱动
        jdbc_driver_library &#x3D;&gt; &quot;&#x2F;opt&#x2F;elasticsearch&#x2F;logstash-7.10.2&#x2F;mysql&#x2F;mysql-connector-java-8.0.21.jar&quot;
        # 驱动类名
        jdbc_driver_class &#x3D;&gt; &quot;com.mysql.cj.jdbc.Driver&quot;
        jdbc_paging_enabled &#x3D;&gt; &quot;true&quot;
        jdbc_page_size &#x3D;&gt; &quot;50000&quot;
        # 执行的sql 文件路径+名称
        statement_filepath &#x3D;&gt; &quot;&#x2F;opt&#x2F;elasticsearch&#x2F;logstash-7.10.2&#x2F;mysql&#x2F;full-sync&#x2F;jdbc.sql&quot;
        # 设置监听间隔 各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新
        schedule &#x3D;&gt; &quot;* * * * *&quot;
    &#125;
&#125;

output &#123;
        elasticsearch &#123;
                #ES的连接信息
                hosts &#x3D;&gt; [&quot;192.168.10.30:9200&quot;]
                #索引名称
                index &#x3D;&gt; &quot;hotel&quot;
                document_type &#x3D;&gt; &quot;_doc&quot;
                #自增ID， 需要关联的数据库的ID字段， 对应索引的ID标识
                document_id &#x3D;&gt; &quot;%&#123;id&#125;&quot;
        &#125;
        stdout &#123;
                #JSON格式输出
                codec &#x3D;&gt; json_lines
        &#125;
&#125;

</code></pre>

<p>jdbc.sql文件：</p>
<pre class="line-numbers language-none"><code class="language-none">SELECT
        id,
        NAME,
        address,
        brand,
        type,
        price,
        specs,
        salesVolume,
        synopsis,
        area,
        imageUrl,
        createTime,
        isAd
FROM
        t_hotel</code></pre>

<h4 id="5-2-5-执行全量同步"><a href="#5-2-5-执行全量同步" class="headerlink" title="5.2.5 执行全量同步"></a>5.2.5 执行全量同步</h4><pre class="line-numbers language-none"><code class="language-none">[root@linux30 full-sync]# ..&#x2F;..&#x2F;bin&#x2F;logstash -f jdbc.conf
</code></pre>

<h4 id="5-2-6-检查结果"><a href="#5-2-6-检查结果" class="headerlink" title="5.2.6 检查结果"></a>5.2.6 检查结果</h4><pre class="line-numbers language-none"><code class="language-none">GET hotel&#x2F;_search</code></pre>

<h3 id="5-3-增量索引同步"><a href="#5-3-增量索引同步" class="headerlink" title="5.3 增量索引同步"></a>5.3 增量索引同步</h3><h4 id="5-3-1-修改jdbc-conf配置文件"><a href="#5-3-1-修改jdbc-conf配置文件" class="headerlink" title="5.3.1 修改jdbc.conf配置文件"></a>5.3.1 修改jdbc.conf配置文件</h4><pre class="line-numbers language-none"><code class="language-none">input &#123;
    stdin &#123;
    &#125;
    jdbc &#123;
        # mysql 数据库链接,users为数据库名
        jdbc_connection_string &#x3D;&gt; &quot;jdbc:mysql:&#x2F;&#x2F;192.168.10.30:3306&#x2F;elasticsearch_db&quot;
        # 用户名和密码
        jdbc_user &#x3D;&gt; &quot;root&quot;
        jdbc_password &#x3D;&gt; &quot;123456&quot;
        # 驱动
        jdbc_driver_library &#x3D;&gt; &quot;&#x2F;opt&#x2F;elasticsearch&#x2F;logstash-7.10.2&#x2F;mysql&#x2F;mysql-connector-java-8.0.21.jar&quot;
        # 驱动类名
        jdbc_driver_class &#x3D;&gt; &quot;com.mysql.cj.jdbc.Driver&quot;
        jdbc_paging_enabled &#x3D;&gt; &quot;true&quot;
        jdbc_page_size &#x3D;&gt; &quot;50000&quot;
        # 执行的sql 文件路径+名称
        statement_filepath &#x3D;&gt; &quot;&#x2F;opt&#x2F;elasticsearch&#x2F;logstash-7.10.2&#x2F;mysql&#x2F;inc-sync&#x2F;jdbc.sql&quot;
        # 设置监听间隔 各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新
        schedule &#x3D;&gt; &quot;* * * * *&quot;
        #设置timezone
        jdbc_default_timezone &#x3D;&gt; &quot;Asia&#x2F;Shanghai&quot;
        # 增量同步属性标识
        last_run_metadata_path &#x3D;&gt; &quot;&#x2F;opt&#x2F;elasticsearch&#x2F;logstash-7.10.2&#x2F;mysql&#x2F;inc-sync&#x2F;last_value&quot;
    &#125;
&#125;

output &#123;
        elasticsearch &#123;
                #ES的连接信息
                hosts &#x3D;&gt; [&quot;192.168.10.30:9200&quot;]
                #索引名称
                index &#x3D;&gt; &quot;hotel&quot;
                document_type &#x3D;&gt; &quot;_doc&quot;
                #自增ID， 需要关联的数据库的ID字段， 对应索引的ID标识
                document_id &#x3D;&gt; &quot;%&#123;id&#125;&quot;
        &#125;
        stdout &#123;
                #JSON格式输出
                codec &#x3D;&gt; json_lines
        &#125;
&#125;
</code></pre>

<h4 id="5-3-2-修改jdbc-sql配置文件"><a href="#5-3-2-修改jdbc-sql配置文件" class="headerlink" title="5.3.2 修改jdbc.sql配置文件"></a>5.3.2 修改jdbc.sql配置文件</h4><pre class="line-numbers language-none"><code class="language-none">SELECT
        id,
        NAME,
        address,
        brand,
        type,
        price,
        specs,
        salesVolume,
        synopsis,
        area,
        imageUrl,
        createTime,
        isAd
FROM
        t_hotel
WHERE
        createTime &gt;&#x3D; :sql_last_value
        
        
        
</code></pre>

<h4 id="5-3-3-创建同步最后记录时间"><a href="#5-3-3-创建同步最后记录时间" class="headerlink" title="5.3.3 创建同步最后记录时间"></a>5.3.3 创建同步最后记录时间</h4><pre class="line-numbers language-none"><code class="language-none">vi &#x2F;opt&#x2F;elasticsearch&#x2F;logstash-7.10.2&#x2F;mysql&#x2F;inc-sync&#x2F;last_value</code></pre>

<p>给定一个初始的时间：</p>
<pre class="line-numbers language-none"><code class="language-none">2022-04-12 00:00:00</code></pre>

<h4 id="5-3-4-验证"><a href="#5-3-4-验证" class="headerlink" title="5.3.4 验证"></a>5.3.4 验证</h4><p>启动logstash， 会根据初始时间，加载对应的数据。</p>
<p>如果修改的数据的更新时间， 会自动检测， 同步增量的数据。</p>
<pre class="line-numbers language-none"><code class="language-none">MySQL [elasticsearch_db]&gt; insert into elasticsearch_db.t_hotel (name, address, brand, type, price, specs, salesVolume, synopsis, area, imageUrl, createTime, isAd) values (&quot;test hotel&quot;,&quot;test address&quot;, &quot;test brand&quot;, &quot;test type&quot;, 100, &quot;test specs&quot;, 100, &quot;test data&quot;, &quot;test data&quot;, &quot;www.baidu.com&quot;, &quot;2022-06-17&quot;, 1);
Query OK, 1 row affected, 1 warning (0.01 sec)


GET hotel&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;name&quot;: &quot;test hotel&quot;
    &#125;
  &#125;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/Es%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8.html" data-id="claw5tqbb00025wtd1kmfb879" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">计算机原理</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/Es%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8.html">Es原理与使用</a>
          </li>
        
          <li>
            <a href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86.html">计算机原理</a>
          </li>
        
          <li>
            <a href="/post/hello-world.html">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>